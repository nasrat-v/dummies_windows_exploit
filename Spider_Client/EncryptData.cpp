
#include "stdafx.h"
#include "EncryptData.hh"

static const std::string base64_chars =

"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"
"0123456789+/";

int RandomNumber() { return (10); }

EncryptData::EncryptData()
{
	oneKey = "abcdefghijklmnop";
	initVector = false;
}

EncryptData::~EncryptData()
{
}

const std::string			EncryptData::translateKey(const void *const apBuffer, size_t aSize) const
{
	static const unsigned char key32[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,22, 23, 24, 25, 26, 27, 28, 29, 30, 31 };
	const char *const Buffer = reinterpret_cast<const char *>(apBuffer);
	std::string Result(reinterpret_cast<const char *>(key32), 32);
	std::copy(Buffer, Buffer + ((aSize < 32) ? aSize : 32), Result.begin());
	return Result;
}

size_t						EncryptData::paddingSize(const size_t len) const
{
	if (len % AES_BLOCK_SIZE == 0) 
		return (len);
	return (((len / AES_BLOCK_SIZE) + 1) * AES_BLOCK_SIZE);
}

const std::string			EncryptData::encrypt(const void *const apBuffer, size_t aBufferSize, const void *const apKey, size_t aKeySize)
{
	initVector = true;
	unsigned char AES_IVector[AES_BLOCK_SIZE] = { 0 };

	std::srand(static_cast<int>(0));
	std::generate(std::begin(AES_IVector), std::end(AES_IVector), RandomNumber);
	aIVector.resize(sizeof(AES_IVector));
	std::copy(std::begin(AES_IVector), std::end(AES_IVector), aIVector.begin());

	const std::string Key(translateKey(apKey, aKeySize));
	AES_KEY EncryptKey;
	AES_set_encrypt_key(reinterpret_cast<const unsigned char *>(Key.data()), _ENCRYPT_BITS, &EncryptKey);

	unsigned char AES_Encrypted[_BUFFER_SIZE] = { 0 };
	AES_cbc_encrypt(static_cast<const unsigned char *>(apBuffer), AES_Encrypted, aBufferSize, &EncryptKey, AES_IVector, AES_ENCRYPT);
	const std::string Encrypted(reinterpret_cast<const char *>(AES_Encrypted), paddingSize(aBufferSize));

	return Encrypted;
}

const std::string			EncryptData::decrypt(const void *const apBuffer, size_t aBufferSize, const void *const apKey, size_t aKeySize)
{
	unsigned char AES_IVector[AES_BLOCK_SIZE] = { 0 };

	if (initVector == false)
	{
		initVector = true;
		encrypt(apBuffer, aBufferSize, apKey, aKeySize);
	}

	std::copy(aIVector.begin(), aIVector.end(), std::begin(AES_IVector));

	const std::string Key(translateKey(apKey, aKeySize));
	AES_KEY DecryptKey;
	AES_set_decrypt_key(reinterpret_cast<const unsigned char *>(Key.data()), _ENCRYPT_BITS, &DecryptKey);

	unsigned char AES_Decrypted[_BUFFER_SIZE] = { 0 };
	AES_cbc_encrypt(static_cast<const unsigned char *>(apBuffer), AES_Decrypted, aBufferSize, &DecryptKey, AES_IVector, AES_DECRYPT);
	const std::string Decrypted(reinterpret_cast<const char *>(AES_Decrypted));

	return Decrypted;
}

const std::string		EncryptData::encryptData(std::string content)
{
	std::string			sslEncrypted = this->sslEncrypt(content);
	return (base64_encode(reinterpret_cast<const unsigned char*>(sslEncrypted.c_str()), sslEncrypted.length()));
}

const std::string		EncryptData::decryptData(std::string content)
{
	std::string			b64Encoded = base64_decode(content);
	return (this->sslDecrypt(b64Encoded));
}

const std::string		EncryptData::sslEncrypt(const std::string &content)
{
	std::vector<unsigned char> IV;
	std::string res(encrypt(content.data(), content.size(), oneKey.data(), oneKey.size()));
	return (res);
}

const std::string		EncryptData::sslDecrypt(const std::string &content)
{
	std::vector<unsigned char> IV;
	return (decrypt(content.data(), content.size(), oneKey.data(), oneKey.size()));
}

const std::string			EncryptData::encryptBuffer(const std::string buffer)
{
	int						nbCutting;
	int						offset;
	int						cnt = -1;
	std::string				keyBuffer;

	if (buffer.size() > AES_BLOCK_SIZE)
	{
		nbCutting = (buffer.size() / AES_BLOCK_SIZE);
		while (++cnt < nbCutting)
		{
			offset = (cnt * AES_BLOCK_SIZE);
			keyBuffer += encryptData(buffer.substr(offset, AES_BLOCK_SIZE));
		}
		if ((buffer.size() % AES_BLOCK_SIZE) != 0)
			keyBuffer += encryptData(buffer.substr(offset + AES_BLOCK_SIZE));
	}
	else
		keyBuffer = encryptData(buffer);
	return (keyBuffer);
}

const std::string			EncryptData::decryptBuffer(const std::string buffer)
{
	int						nbCutting;
	int						offset;
	int						cnt = -1;
	std::string				keyBuffer;

	if (buffer.size() > AES_BLOCK_SIZE)
	{
		nbCutting = (buffer.size() / AES_BLOCK_SIZE);
		while (++cnt < nbCutting)
		{
			offset = (cnt * AES_BLOCK_SIZE);
			keyBuffer += decryptData(buffer.substr(offset, AES_BLOCK_SIZE));
		}
		if ((buffer.size() % AES_BLOCK_SIZE) != 0)
			keyBuffer += decryptData(buffer.substr(offset + AES_BLOCK_SIZE));
	}
	else
		keyBuffer = decryptData(buffer);
	return (keyBuffer);
}

inline bool				EncryptData::is_base64(unsigned char c)
{
	return (isalnum(c) || (c == '+') || (c == '/'));
}

std::string				EncryptData::base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len)
{
	std::string			ret;
	int					i = 0;
	int					j = 0;
	unsigned char		char_array_3[3];
	unsigned char		char_array_4[4];

	while (in_len--) 
	{
		char_array_3[i++] = *(bytes_to_encode++);
		if (i == 3) {
			char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
			char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
			char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
			char_array_4[3] = char_array_3[2] & 0x3f;

			for (i = 0; (i < 4); i++)
				ret += base64_chars[char_array_4[i]];
			i = 0;
		}
	}
	if (i)
	{
		for (j = i; j < 3; j++)
			char_array_3[j] = '\0';
		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
		char_array_4[3] = char_array_3[2] & 0x3f;
		for (j = 0; (j < i + 1); j++)
			ret += base64_chars[char_array_4[j]];
		while ((i++ < 3))
			ret += '=';
	}
	return (ret);
}

std::string				EncryptData::base64_decode(std::string const& encoded_string)
{
	size_t				in_len = encoded_string.size();
	size_t				i = 0;
	size_t				j = 0;
	int					in_ = 0;
	unsigned char		char_array_4[4], char_array_3[3];
	std::string			ret;

	while (in_len-- && (encoded_string[in_] != '=') && is_base64(encoded_string[in_]))
	{
		char_array_4[i++] = encoded_string[in_]; in_++;
		if (i == 4)
		{
			for (i = 0; i <4; i++)
				char_array_4[i] = static_cast<unsigned char>(base64_chars.find(char_array_4[i]));
			char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
			char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
			char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
			for (i = 0; (i < 3); i++)
				ret += char_array_3[i];
			i = 0;
		}
	}
	if (i) 
	{
		for (j = i; j <4; j++)
			char_array_4[j] = 0;
		for (j = 0; j <4; j++)
			char_array_4[j] = static_cast<unsigned char>(base64_chars.find(char_array_4[j]));
		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
		for (j = 0; (j < i - 1); j++) 
			ret += char_array_3[j];
	}
	return (ret);
}

